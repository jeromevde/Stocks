/**
 * Portfolio management module
 * Handles portfolio data, saving, loading, and state management
 */

// Portfolio state
let portfolio = [];
let hasUnsavedChanges = false;
let initialPortfolioHash = null;

// Sorting and filter state
let sortByCumulativeReturn = false;
let sortBy3MonthReturn = false;
let labelFilterSet = new Set();
let showZeroStarStocks = false;

/**
 * Calculate a hash of the portfolio for change detection
 */
function calculatePortfolioHash() {
    const portfolioString = JSON.stringify(
        portfolio.map(stock => ({
            ticker: stock.ticker,
            date: stock.date,
            labels: stock.labels.slice().sort(),
            notes: stock.notes,
            rating: stock.rating || 0
        })).sort((a, b) => a.ticker.localeCompare(b.ticker))
    );
    
    let hash = 0;
    for (let i = 0; i < portfolioString.length; i++) {
        const char = portfolioString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return hash;
}

/**
 * Mark portfolio as having unsaved changes
 */
function markPortfolioChanged() {
    hasUnsavedChanges = true;
    
    if (typeof updateSaveButtonState === 'function') {
        updateSaveButtonState();
    }
    
    // Update page title
    if (!document.title.includes('*')) {
        document.title = '* Stock Tracker';
    }
    
    // Start autosave timer if available
    if (typeof startAutosaveTimer === 'function') {
        startAutosaveTimer();
    }
}

/**
 * Mark portfolio as saved
 */
function markPortfolioSaved() {
    hasUnsavedChanges = false;
    initialPortfolioHash = calculatePortfolioHash();
    
    if (typeof updateSaveButtonState === 'function') {
        updateSaveButtonState();
    }
    
    document.title = 'Stock Tracker';
    
    // Update GitHub client's saved state
    if (window.githubClient) {
        const htmlContent = generateHtmlContent();
        window.githubClient.markAsSaved(htmlContent);
    }
}

/**
 * Generate HTML content for saving to GitHub
 */
function generateHtmlContent() {
    const timestamp = new Date().toISOString();
    
    let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Portfolio</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #f4f4f4; }
    tr:nth-child(even) { background: #fafafa; }
    .star { color: gold; font-size: 1.2em; }
  </style>
</head>
<body>
  <h1>Portfolio</h1>
  <p><em>Last updated: ${timestamp}</em></p>
  <table>
    <thead>
      <tr>
        <th>Ticker</th>
        <th>Name</th>
        <th>Date</th>
        <th>Labels</th>
        <th>Notes</th>
        <th>Rating</th>
      </tr>
    </thead>
    <tbody>
`;

    portfolio.forEach(s => {
        const labels = s.labels.join(', ');
        const notes = (s.notes || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const rating = s.rating || 0;
        const ratingStars = '‚òÖ'.repeat(rating) + '‚òÜ'.repeat(5 - rating);
        const name = (s.name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html += `      <tr><td>${s.ticker}</td><td>${name}</td><td>${s.date}</td><td>${labels}</td><td>${notes}</td><td><span class="star">${ratingStars}</span> (${rating})</td></tr>\n`;
    });

    html += `    </tbody>
  </table>
  <p><small>Generated by Stock Tracker - ${portfolio.length} stocks tracked</small></p>
</body>
</html>
`;
    return html;
}

/**
 * Parse HTML content from GitHub into portfolio data
 */
function parseHtmlContent(content) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(content, 'text/html');
    const rows = doc.querySelectorAll('table tbody tr');
    const portfolioData = [];
    
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length === 6) {
            const labels = cells[3].textContent.split(',').map(l => l.trim()).filter(Boolean);
            const notes = cells[4].textContent;
            
            // Parse rating
            const ratingText = cells[5].textContent;
            let rating = 0;
            const ratingMatch = ratingText.match(/\((\d)\)/);
            if (ratingMatch) {
                rating = parseInt(ratingMatch[1]);
            } else {
                rating = (ratingText.match(/‚òÖ/g) || []).length;
            }
            
            portfolioData.push({
                ticker: cells[0].textContent,
                name: cells[1].textContent,
                date: cells[2].textContent,
                labels,
                notes,
                rating,
                nowPrice: 'Loading...',
                cumulativeReturn: 'Calculating...',
                return3m: 'Loading...'
            });
        }
    });
    
    return portfolioData;
}

/**
 * Save portfolio to GitHub
 */
async function savePortfolioToMarkdown() {
    const saveButton = document.getElementById('save-portfolio');
    if (!saveButton || saveButton.disabled) return;

    try {
        if (!window.githubClient || !window.githubClient.isAuthenticated()) {
            const authModal = document.getElementById('github-auth-modal');
            if (authModal) {
                authModal.style.display = 'flex';
                const tokenInput = document.getElementById('github-token');
                if (tokenInput) setTimeout(() => tokenInput.focus(), 100);
            }
            showStatus('Please authenticate with GitHub to save your portfolio', 'error');
            return;
        }

        saveButton.disabled = true;
        saveButton.textContent = 'üíæ Saving...';
        showStatus('Saving to GitHub...', 'info');

        const content = generateHtmlContent();
        const stockCount = portfolio.length;
        const message = `Update portfolio (HTML) - ${stockCount} stock${stockCount !== 1 ? 's' : ''}`;

        await window.githubClient.saveFile(content, message);
        
        markPortfolioSaved();
        showStatus(`‚úÖ Portfolio saved to GitHub (${stockCount} stocks)`, 'success');
        
    } catch (error) {
        console.error('Save error:', error);
        showStatus(`‚ùå Save failed: ${error.message}`, 'error');
        updateSaveButtonState();
    }
}

/**
 * Load portfolio from GitHub
 */
async function loadPortfolioFromGitHub() {
    try {
        showStatus('Loading portfolio from GitHub...', 'info');
        
        const result = await window.githubClient.loadFile();
        
        if (!result.exists) {
            showStatus('No portfolio file found on GitHub. Start by adding some stocks!', 'info');
            initialPortfolioHash = calculatePortfolioHash();
            markPortfolioSaved();
            return;
        }
        
        showStatus('Parsing portfolio data...', 'info');
        
        const portfolioData = parseHtmlContent(result.content);
        
        portfolio.length = 0;
        portfolio.push(...portfolioData);
        
        initialPortfolioHash = calculatePortfolioHash();
        markPortfolioSaved();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
        
        showStatus(`Portfolio loaded: ${portfolio.length} stocks. Updating prices...`, 'success');
        
        // Fetch fresh prices asynchronously
        await updateAllStockDataAsync(portfolio);
        
    } catch (error) {
        console.error('Load error:', error);
        showStatus(`Load failed: ${error.message}`, 'error');
        initialPortfolioHash = calculatePortfolioHash();
        markPortfolioSaved();
    }
}

/**
 * Force refresh from GitHub (clears cache)
 */
async function forceRefreshFromGitHub() {
    try {
        showStatus('üîÑ Refreshing from GitHub...', 'info');
        
        if (window.githubClient) {
            window.githubClient.clearCache();
        }
        
        if (window.YahooFinance) {
            window.YahooFinance.clearCache();
        }
        
        await loadPortfolioFromGitHub();
        
    } catch (error) {
        console.error('Force refresh error:', error);
        showStatus(`‚ùå Refresh failed: ${error.message}`, 'error');
    }
}

/**
 * Update all stock data asynchronously
 */
async function updateAllStockDataAsync(stocks) {
    if (!stocks || stocks.length === 0) return;
    
    let completed = 0;
    const total = stocks.length;
    const batchSize = 3;
    
    for (let i = 0; i < stocks.length; i += batchSize) {
        const batch = stocks.slice(i, i + batchSize);
        
        const promises = batch.map(async (stock) => {
            try {
                await updateStockData(stock);
                completed++;
                
                if (completed % 3 === 0 || completed === total) {
                    showStatus(`Updated ${completed}/${total} stocks...`, 'info');
                }
            } catch (error) {
                console.error(`Error updating ${stock.ticker}:`, error);
                completed++;
            }
        });
        
        await Promise.all(promises);
        
        if (i + batchSize < stocks.length) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    showStatus(`All ${total} stocks updated!`, 'success');
}

/**
 * Update data for a single stock
 */
async function updateStockData(stock) {
    try {
        const Yahoo = window.YahooFinance;
        
        if (!Yahoo) {
            console.warn('YahooFinance API not loaded yet');
            return;
        }
        
        // Fetch current price
        const currentPrice = await Yahoo.fetchCurrentPrice(stock.ticker);
        if (currentPrice !== null) {
            stock.nowPrice = currentPrice.toFixed(2);
        } else {
            stock.nowPrice = 'N/A';
        }
        
        // Fetch historical price and calculate return
        const historicalPrice = await Yahoo.fetchHistoricalPrice(stock.ticker, stock.date);
        if (historicalPrice !== null && currentPrice !== null) {
            const returnPercent = ((currentPrice - historicalPrice) / historicalPrice * 100);
            stock.cumulativeReturn = returnPercent.toFixed(2);
        } else {
            stock.cumulativeReturn = 'N/A';
        }
        
        // Fetch 3-month return
        const return3m = await Yahoo.fetch3MonthReturn(stock.ticker);
        stock.return3m = return3m || 'N/A';
        
        if (typeof debouncedUpdateTable === 'function') {
            debouncedUpdateTable();
        }
        
    } catch (error) {
        console.error(`Error updating ${stock.ticker}:`, error);
        stock.nowPrice = stock.nowPrice === 'Loading...' ? 'N/A' : stock.nowPrice;
        stock.cumulativeReturn = stock.cumulativeReturn === 'Calculating...' ? 'N/A' : stock.cumulativeReturn;
        stock.return3m = stock.return3m === 'Loading...' ? 'N/A' : stock.return3m;
    }
}

/**
 * Add a new stock to the portfolio
 */
async function addStock(ticker) {
    try {
        const Yahoo = window.YahooFinance;
        if (!Yahoo) {
            console.error('YahooFinance API not loaded');
            alert('Unable to add stock: API not loaded. Please refresh the page.');
            return false;
        }
        
        const tickerUpper = ticker.toUpperCase();
        
        // Check for duplicate ticker
        if (portfolio.some(s => s.ticker.toUpperCase() === tickerUpper)) {
            alert(`${tickerUpper} is already in your portfolio.`);
            return false;
        }
        
        // Validate ticker exists
        const suggestions = await Yahoo.fetchTickerSuggestions(ticker);
        const matchedStock = suggestions.find(s => s.symbol.toUpperCase() === tickerUpper);
        
        if (!matchedStock) {
            alert('Stock ticker not found. Please try again.');
            return false;
        }
        
        const date = new Date().toISOString().slice(0, 10);
        
        // Add stock with loading state
        const stock = {
            ticker: ticker.toUpperCase(),
            name: matchedStock.name || ticker,
            date,
            labels: [],
            notes: '',
            nowPrice: '...',
            cumulativeReturn: '...',
            return3m: '...',
            rating: 0,
            loading: true
        };
        
        portfolio.push(stock);
        markPortfolioChanged();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
        
        // Fetch prices asynchronously
        try {
            const [startPrice, nowPrice, return3m] = await Promise.all([
                Yahoo.fetchHistoricalPrice(ticker, date),
                Yahoo.fetchCurrentPrice(ticker),
                Yahoo.fetch3MonthReturn(ticker)
            ]);
            
            const stockIndex = portfolio.findIndex(s => s.ticker === ticker.toUpperCase() && s.loading);
            if (stockIndex !== -1) {
                if (startPrice != null && nowPrice != null) {
                    portfolio[stockIndex].nowPrice = Number(nowPrice).toFixed(2);
                    portfolio[stockIndex].cumulativeReturn = ((nowPrice - startPrice) / startPrice * 100).toFixed(2);
                } else {
                    portfolio[stockIndex].nowPrice = 'N/A';
                    portfolio[stockIndex].cumulativeReturn = 'N/A';
                }
                portfolio[stockIndex].return3m = return3m || 'N/A';
                portfolio[stockIndex].loading = false;
                
                if (typeof updatePortfolioTable === 'function') {
                    updatePortfolioTable();
                }
            }
        } catch (error) {
            const stockIndex = portfolio.findIndex(s => s.ticker === ticker.toUpperCase() && s.loading);
            if (stockIndex !== -1) {
                portfolio[stockIndex].nowPrice = 'Error';
                portfolio[stockIndex].cumulativeReturn = 'Error';
                portfolio[stockIndex].return3m = 'Error';
                portfolio[stockIndex].loading = false;
                
                if (typeof updatePortfolioTable === 'function') {
                    updatePortfolioTable();
                }
            }
        }
        
        return true;
    } catch (error) {
        console.error('Error adding stock:', error);
        alert('Error adding stock. Please try again.');
        return false;
    }
}

/**
 * Remove a stock from the portfolio
 */
function removeStock(index) {
    const stock = portfolio[index];
    if (!stock) return;
    
    if (confirm(`Are you sure you want to remove ${stock.ticker} from your portfolio?`)) {
        portfolio.splice(index, 1);
        markPortfolioChanged();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
        
        showStatus(`${stock.ticker} removed from portfolio`, 'info');
    }
}

/**
 * Update stock rating
 */
function updateStockRating(index, newRating) {
    if (portfolio[index]) {
        // Toggle: if clicking same rating, set to 0
        portfolio[index].rating = (portfolio[index].rating === newRating) ? 0 : newRating;
        markPortfolioChanged();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
    }
}

/**
 * Update stock date
 */
async function updateStockDate(index, newDate) {
    if (!portfolio[index]) return;
    
    portfolio[index].date = newDate;
    markPortfolioChanged();
    
    // Fetch updated prices
    const stock = portfolio[index];
    const Yahoo = window.YahooFinance;
    
    try {
        const [startPrice, nowPrice] = await Promise.all([
            Yahoo.fetchHistoricalPrice(stock.ticker, newDate),
            Yahoo.fetchCurrentPrice(stock.ticker)
        ]);
        
        if (portfolio[index]) {
            portfolio[index].nowPrice = nowPrice ? Number(nowPrice).toFixed(2) : 'N/A';
            portfolio[index].cumulativeReturn = (startPrice && nowPrice) 
                ? ((nowPrice - startPrice) / startPrice * 100).toFixed(2) 
                : 'N/A';
            
            if (typeof updatePortfolioTable === 'function') {
                updatePortfolioTable();
            }
        }
    } catch (error) {
        console.error(`Error updating prices for ${stock.ticker}:`, error);
    }
}

/**
 * Add a label to a stock
 */
function addStockLabel(index, label) {
    if (portfolio[index] && label && !portfolio[index].labels.includes(label)) {
        portfolio[index].labels.push(label);
        markPortfolioChanged();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
    }
}

/**
 * Remove a label from a stock
 */
function removeStockLabel(index, label) {
    if (portfolio[index]) {
        portfolio[index].labels = portfolio[index].labels.filter(l => l !== label);
        markPortfolioChanged();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
    }
}

/**
 * Update stock notes
 */
function updateStockNotes(index, notes) {
    if (portfolio[index]) {
        portfolio[index].notes = notes;
        markPortfolioChanged();
        
        if (typeof updatePortfolioTable === 'function') {
            updatePortfolioTable();
        }
    }
}

/**
 * Get sorted and filtered portfolio
 */
function getSortedFilteredPortfolio() {
    let sorted = [...portfolio];
    
    // Sort by rating first, then by return metrics if requested
    sorted.sort((a, b) => {
        const aRating = a.rating || 0;
        const bRating = b.rating || 0;
        if (aRating !== bRating) return bRating - aRating;
        
        if (sortByCumulativeReturn) {
            const aVal = parseFloat(a.cumulativeReturn) || -Infinity;
            const bVal = parseFloat(b.cumulativeReturn) || -Infinity;
            return bVal - aVal;
        }
        if (sortBy3MonthReturn) {
            const aVal = parseFloat(a.return3m) || -Infinity;
            const bVal = parseFloat(b.return3m) || -Infinity;
            return bVal - aVal;
        }
        return 0;
    });
    
    // Filter by labels
    if (labelFilterSet.size > 0) {
        sorted = sorted.filter(stock => stock.labels.some(label => labelFilterSet.has(label)));
    }
    
    return sorted;
}

// Export for use in other modules
window.Portfolio = {
    get data() { return portfolio; },
    get hasUnsavedChanges() { return hasUnsavedChanges; },
    
    // Sorting/filtering state
    get sortByCumulativeReturn() { return sortByCumulativeReturn; },
    set sortByCumulativeReturn(val) { sortByCumulativeReturn = val; sortBy3MonthReturn = false; },
    get sortBy3MonthReturn() { return sortBy3MonthReturn; },
    set sortBy3MonthReturn(val) { sortBy3MonthReturn = val; sortByCumulativeReturn = false; },
    get labelFilterSet() { return labelFilterSet; },
    get showZeroStarStocks() { return showZeroStarStocks; },
    set showZeroStarStocks(val) { showZeroStarStocks = val; },
    
    // Methods
    save: savePortfolioToMarkdown,
    load: loadPortfolioFromGitHub,
    refresh: forceRefreshFromGitHub,
    add: addStock,
    remove: removeStock,
    updateRating: updateStockRating,
    updateDate: updateStockDate,
    addLabel: addStockLabel,
    removeLabel: removeStockLabel,
    updateNotes: updateStockNotes,
    getSortedFiltered: getSortedFilteredPortfolio,
    markChanged: markPortfolioChanged,
    markSaved: markPortfolioSaved,
    generateHtml: generateHtmlContent
};
