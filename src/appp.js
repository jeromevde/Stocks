// Helper: Fetch ticker suggestions from Yahoo Finance
async function fetchTickerSuggestions(query) {
    if (!query) return [];
    const CORS_PROXY = 'https://corsproxy.io/?';
    const url = CORS_PROXY + `https://query1.finance.yahoo.com/v1/finance/search?q=${encodeURIComponent(query)}&quotesCount=5&newsCount=0`;
    try {
        const res = await fetch(url);
        const data = await res.json();
        return (data.quotes || []).map(q => ({symbol: q.symbol, name: q.shortname || q.longname || q.symbol}));
    } catch (e) {
        return [];
    }
}

// Global variables
let portfolio = [];
let sortByCumulativeReturn = false;
let labelFilterSet = new Set();
let tableUpdateTimeout = null;
let hasUnsavedChanges = false;
let initialPortfolioHash = null;

// Portfolio change tracking functions
function calculatePortfolioHash() {
    const portfolioString = JSON.stringify(portfolio.map(stock => ({
        ticker: stock.ticker,
        date: stock.date,
        labels: stock.labels.slice().sort(), // Sort labels for consistent hashing
        notes: stock.notes,
        starred: stock.starred
    })).sort((a, b) => a.ticker.localeCompare(b.ticker))); // Sort by ticker for consistency
    
    let hash = 0;
    for (let i = 0; i < portfolioString.length; i++) {
        const char = portfolioString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return hash;
}

function markPortfolioChanged() {
    hasUnsavedChanges = true;
    updateSaveButtonState();
    
    // Update page title to indicate unsaved changes
    if (!document.title.includes('*')) {
        document.title = '* Stock Tracker';
    }
}

function markPortfolioSaved() {
    hasUnsavedChanges = false;
    initialPortfolioHash = calculatePortfolioHash();
    updateSaveButtonState();
    
    // Remove unsaved indicator from title
    document.title = 'Stock Tracker';
    
    // Update GitHub client's saved state
    if (window.githubClient) {
        const markdownContent = generateMarkdownContent();
        window.githubClient.markAsSaved(markdownContent);
    }
}

function updateSaveButtonState() {
    const saveButton = document.getElementById('save-portfolio');
    if (saveButton) {
        if (hasUnsavedChanges) {
            saveButton.disabled = false;
            saveButton.textContent = 'ðŸ’¾ Save to GitHub';
            saveButton.style.opacity = '1';
            saveButton.style.cursor = 'pointer';
            saveButton.title = 'Save changes to GitHub';
            saveButton.classList.add('has-changes');
        } else {
            saveButton.disabled = true;
            saveButton.textContent = 'ðŸ’¾ No changes to save';
            saveButton.style.opacity = '0.5';
            saveButton.style.cursor = 'not-allowed';
            saveButton.title = 'No changes to save';
            saveButton.classList.remove('has-changes');
        }
    }
}

function generateMarkdownContent() {
    let md = '# Portfolio\n\n';
    md += `Last updated: ${new Date().toISOString()}\n\n`;
    md += '| Ticker | Name | Date | Labels | Notes | Starred |\n';
    md += '|--------|------|------|--------|---------|---------|\n';
    
    portfolio.forEach(s => {
        const labels = s.labels.join(', ');
        const notes = s.notes.replace(/\|/g, '\\|'); // Escape pipes in notes
        const starred = s.starred ? 'true' : 'false';
        const name = (s.name || '').replace(/\|/g, '\\|'); // Escape pipes in name
        md += `| ${s.ticker} | ${name} | ${s.date} | ${labels} | ${notes} | ${starred} |\n`;
    });
    
    md += `\n---\n*Generated by Stock Tracker - ${portfolio.length} stocks tracked*\n`;
    return md;
}

// Debounced table update to prevent excessive re-renders
function debouncedUpdateTable() {
    if (tableUpdateTimeout) {
        clearTimeout(tableUpdateTimeout);
    }
    tableUpdateTimeout = setTimeout(() => {
        updatePortfolioTable();
    }, 100);
}

// Fetch historical price from Yahoo
async function fetchHistoricalPrice(ticker, date) {
    const targetDate = new Date(date);
    const start = Math.floor(targetDate.getTime() / 1000);
    
    // Add extra days to handle weekends and holidays - look back up to 7 days
    const endDate = new Date(targetDate.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days later
    const end = Math.floor(endDate.getTime() / 1000);
    
    const CORS_PROXY = 'https://corsproxy.io/?';
    const url = CORS_PROXY + `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?period1=${start}&period2=${end}&interval=1d`;
    try {
        const res = await fetch(url);
        const data = await res.json();
        
        // Defensive checks for missing data
        if (
            !data.chart ||
            !data.chart.result ||
            !data.chart.result[0] ||
            !data.chart.result[0].indicators ||
            !data.chart.result[0].indicators.quote[0] ||
            !data.chart.result[0].indicators.quote[0].close
        ) {
            return null;
        }
        
        const prices = data.chart.result[0].indicators.quote[0].close;
        const timestamps = data.chart.result[0].timestamp;
        
        if (!prices || !timestamps || prices.length === 0) {
            return null;
        }
        
        // Find the first valid price on or after the target date
        for (let i = 0; i < timestamps.length; i++) {
            const priceDate = new Date(timestamps[i] * 1000);
            if (priceDate >= targetDate && prices[i] != null) {
                return prices[i];
            }
        }
        
        // If no price found on or after target date, use the last available price
        for (let i = prices.length - 1; i >= 0; i--) {
            if (prices[i] != null) {
                return prices[i];
            }
        }
        
        return null;
    } catch (e) {
        return null;
    }
}

// Fetch current price from Yahoo Finance
async function fetchCurrentPrice(ticker) {
    const CORS_PROXY = 'https://corsproxy.io/?';
    const url = CORS_PROXY + `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?range=1d&interval=1m`;
    try {
        const res = await fetch(url);
        const data = await res.json();
        // Get the most recent price
        if (
            data.chart &&
            data.chart.result &&
            data.chart.result[0] &&
            data.chart.result[0].meta &&
            data.chart.result[0].meta.regularMarketPrice
        ) {
            return data.chart.result[0].meta.regularMarketPrice;
        }
        return null;
    } catch (e) {
        return null;
    }
}

// Save portfolio to markdown and upload to GitHub
async function savePortfolioToMarkdown() {
    const saveButton = document.getElementById('save-portfolio');
    if (!saveButton || saveButton.disabled) return;

    try {
        // Check if authenticated
        if (!window.githubClient || !window.githubClient.isAuthenticated()) {
            // Show authentication modal
            const authModal = document.getElementById('github-auth-modal');
            if (authModal) {
                authModal.style.display = 'flex';
                const tokenInput = document.getElementById('github-token');
                if (tokenInput) {
                    setTimeout(() => tokenInput.focus(), 100);
                }
            }
            showStatus('Please authenticate with GitHub to save your portfolio', 'error');
            return;
        }

        saveButton.disabled = true;
        saveButton.textContent = 'ðŸ’¾ Saving...';
        showStatus('Saving to GitHub...', 'info');

        const content = generateMarkdownContent();
        const stockCount = portfolio.length;
        const message = `Update portfolio - ${stockCount} stock${stockCount !== 1 ? 's' : ''}`;

        const result = await window.githubClient.saveFile(content, message);
        
        markPortfolioSaved(); // Mark as saved
        showStatus(`âœ… Portfolio saved to GitHub (${stockCount} stocks)`, 'success');
        
    } catch (error) {
        console.error('Save error:', error);
        showStatus(`âŒ Save failed: ${error.message}`, 'error');
        updateSaveButtonState(); // Reset button state
    }
}

// Load portfolio from GitHub
async function loadPortfolioFromGitHub() {
    try {
        showStatus('Loading portfolio from GitHub...', 'info');
        
        // Break up the work - first get the file
        const result = await window.githubClient.loadFile();
        
        if (!result.exists) {
            showStatus('No portfolio file found on GitHub. Start by adding some stocks!', 'info');
            initialPortfolioHash = calculatePortfolioHash(); // Set initial hash for empty portfolio
            markPortfolioSaved();
            return;
        }
        
        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 0));
        
        showStatus('Parsing portfolio data...', 'info');
        
        // Parse the markdown content in chunks
        const portfolioData = await parseMarkdownContent(result.content);
        
        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 0));
        
        // Merge with existing portfolio (keep starred status from loaded data, not local)
        portfolio.length = 0; // Clear existing portfolio
        portfolio.push(...portfolioData);
        
        // Set initial hash and mark as saved since we just loaded
        initialPortfolioHash = calculatePortfolioHash();
        markPortfolioSaved();
        
        // Refresh the table immediately with the loaded data
        updatePortfolioTable();
        
        showStatus(`Portfolio loaded: ${portfolio.length} stocks. Updating prices...`, 'success');
        
        // Allow UI to update before starting price updates
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Fetch fresh data for all stocks asynchronously to avoid blocking
        updateAllStockDataAsync(portfolio);
        
    } catch (error) {
        console.error('Load error:', error);
        showStatus(`Load failed: ${error.message}`, 'error');
        // Set initial hash even on error
        initialPortfolioHash = calculatePortfolioHash();
        markPortfolioSaved();
    }
}

// Separate function to parse markdown content
async function parseMarkdownContent(content) {
    console.log('Parsing markdown content...');
    
    const lines = content.split('\n');
    const portfolioData = [];
    let inTable = false;
    
    for (const line of lines) {
        // Find table header
        if (line.startsWith('|') && line.includes('Ticker')) {
            console.log('Found table header');
            inTable = true;
            continue;
        }
        
        // Skip separator line
        if (line.startsWith('|-----')) {
            continue;
        }
        
        // Process data rows
        if (inTable && line.startsWith('|')) {
            // Split by | but preserve escaped \| characters
            const columns = [];
            let currentCol = '';
            let i = 1; // Start after first |
            
            while (i < line.length - 1) { // End before last |
                if (line[i] === '\\' && line[i + 1] === '|') {
                    // Escaped pipe - add literal pipe to current column
                    currentCol += '|';
                    i += 2;
                } else if (line[i] === '|') {
                    // Column separator - finish current column
                    columns.push(currentCol.trim());
                    currentCol = '';
                    i += 1;
                } else {
                    // Regular character
                    currentCol += line[i];
                    i += 1;
                }
            }
            // Add the last column
            if (currentCol || columns.length > 0) {
                columns.push(currentCol.trim());
            }
            
            // Skip empty rows
            if (columns.every(col => col === '' || /^[\s-]*$/.test(col))) {
                continue;
            }
            
            // Handle different formats: old (4-5 columns) and new (6 columns with name)
            if (columns.length >= 4) {
                let ticker, name, date, labels, notes, starred;
                
                if (columns.length >= 6) {
                    // New format: Ticker | Name | Date | Labels | Notes | Starred
                    [ticker, name, date, labels, notes, starred] = columns;
                } else {
                    // Old format: Ticker | Date | Labels | Notes | [Starred]
                    [ticker, date, labels, notes, starred] = columns;
                    name = ''; // No name in old format
                }
                
                if (ticker && date && ticker !== 'Ticker' && date !== 'Date') {
                    portfolioData.push({
                        ticker: ticker.trim(),
                        name: name ? name.trim() : '', // No need to replace \\| anymore since we handled it during splitting
                        date: date.trim(),
                        labels: labels ? labels.split(',').map(l => l.trim()).filter(l => l) : [],
                        notes: notes ? notes.trim() : '', // No need to replace \\| anymore
                        starred: starred ? starred.trim() === 'true' : false,
                        nowPrice: 'Loading...',
                        cumulativeReturn: 'Calculating...'
                    });
                }
            }
        }
        
        // End of table
        if (inTable && !line.startsWith('|')) {
            break;
        }
    }
    
    console.log(`Portfolio data parsed: ${portfolioData.length} stocks`);
    return portfolioData;
}

// Asynchronously update all stock data with progress feedback
async function updateAllStockDataAsync(stocks) {
    if (!stocks || stocks.length === 0) return;
    
    let completed = 0;
    const total = stocks.length;
    
    // Process stocks in batches to avoid overwhelming the API
    const batchSize = 3;
    
    for (let i = 0; i < stocks.length; i += batchSize) {
        const batch = stocks.slice(i, i + batchSize);
        
        // Process batch in parallel
        const promises = batch.map(async (stock) => {
            try {
                await updateStockData(stock);
                completed++;
                
                // Update status occasionally
                if (completed % 3 === 0 || completed === total) {
                    showStatus(`Updated ${completed}/${total} stocks...`, 'info');
                }
            } catch (error) {
                console.error(`Error updating ${stock.ticker}:`, error);
                completed++;
            }
        });
        
        await Promise.all(promises);
        
        // Small delay between batches
        if (i + batchSize < stocks.length) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    showStatus(`All ${total} stocks updated!`, 'success');
}

// Render portfolio
function updatePortfolioTable() {
    const portfolioTableBody = document.getElementById('portfolio-tbody');
    if (!portfolioTableBody) return;

    // Clear the table
    portfolioTableBody.innerHTML = '';
    
    // Sort: starred first, then by cumulative return if requested
    let sorted = [...portfolio];
    sorted.sort((a, b) => {
        if (a.starred && !b.starred) return -1;
        if (!a.starred && b.starred) return 1;
        if (sortByCumulativeReturn) {
            const aVal = parseFloat(a.cumulativeReturn) || -Infinity;
            const bVal = parseFloat(b.cumulativeReturn) || -Infinity;
            return bVal - aVal;
        }
        return 0;
    });
    
    // Filter by label if any selected
    let filtered = sorted;
    if (labelFilterSet.size > 0) {
        filtered = sorted.filter(stock => stock.labels.some(label => labelFilterSet.has(label)));
    }
    
    // Create and append rows with event listeners
    filtered.forEach(stock => {
        const tr = document.createElement('tr');
        const notesShort = stock.notes && stock.notes.length > 20 ? stock.notes.slice(0, 20) + 'â€¦' : stock.notes;
        const stockIdx = portfolio.indexOf(stock);
        
        tr.innerHTML = `
            <td style="text-align:center;"><button class="star-btn" data-idx="${stockIdx}">${stock.starred ? 'â˜…' : 'â˜†'}</button></td>
            <td style="text-align:center;">
                <div class="ticker-cell" style="cursor:pointer;" data-ticker="${stock.ticker}">
                    <div style="font-weight:bold; color:#0066cc;">${stock.ticker}</div>
                    <div style="font-size:11px; color:#888; margin-top:2px;">${stock.name || ''}</div>
                </div>
            </td>
            <td style="text-align:center;"><input type="date" value="${stock.date}" data-idx="${stockIdx}" class="edit-date" style="width:130px; border:none; background:transparent; font-size:12px; color:#666;"></td>
            <td style="text-align:center;">
                <div class="labels-container" data-idx="${stockIdx}" style="cursor:pointer; min-width:80px; padding:4px; border:1px solid transparent;">
                    ${stock.labels.map(label => `<span class="label-tag" style="display:inline-block; background:#e3f2fd; color:#1976d2; padding:2px 6px; margin:1px; border-radius:3px; font-size:11px;">${label}<span class="remove-label" data-label="${label}" style="margin-left:4px; cursor:pointer; font-weight:bold;">Ã—</span></span>`).join('')}
                    <span class="add-label-btn" style="display:inline-block; background:#f0f0f0; color:#666; padding:2px 6px; margin:1px; border-radius:3px; font-size:11px; cursor:pointer;">+</span>
                </div>
                <div class="label-popup" data-idx="${stockIdx}" style="display:none; position:absolute; background:white; border:1px solid #ccc; border-radius:4px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:1000;">
                    <input type="text" class="label-input" placeholder="Add label" style="width:120px; padding:4px; margin-bottom:8px; border:1px solid #ccc; border-radius:3px;">
                    <div>
                        <button class="add-label-confirm" style="padding:4px 8px; margin-right:4px; background:#4caf50; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">Add</button>
                        <button class="cancel-label" style="padding:4px 8px; background:#f44336; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">Cancel</button>
                    </div>
                </div>
            </td>
            <td style="text-align:center;">
                <span class="notes-display" data-idx="${stockIdx}" style="cursor:pointer; display:inline-block; min-width:80px; padding:8px; border:1px solid transparent; background:#f9f9f9; color:#666; border-radius:3px; min-height:16px;">${notesShort || ''}</span>
            </td>
            <td style="text-align:right;">${stock.nowPrice != null ? (stock.loading ? '...' : '$' + stock.nowPrice) : ''}</td>
            <td class="cumulative-return" style="text-align:right; color: ${stock.loading || !stock.cumulativeReturn || stock.cumulativeReturn === 'N/A' || stock.cumulativeReturn === 'Error' ? '#666' : (parseFloat(stock.cumulativeReturn) >= 0 ? '#4caf50' : '#f44336')};">${stock.loading ? '...' : (stock.cumulativeReturn !== 'N/A' && stock.cumulativeReturn !== 'Error' ? stock.cumulativeReturn + '%' : stock.cumulativeReturn)}</td>
            <td style="text-align:center; width:30px;"><button class="remove-btn" data-idx="${stockIdx}" style="background:none; color:#ccc; border:none; cursor:pointer; padding:2px; font-size:16px; transition:color 0.2s; line-height:1;">Ã—</button></td>
        `;
        
        // Star button event listener
        const starBtn = tr.querySelector('.star-btn');
        starBtn.addEventListener('click', () => {
            portfolio[stockIdx].starred = !portfolio[stockIdx].starred;
            markPortfolioChanged(); // Mark as changed
            updatePortfolioTable();
        });
        
        // Remove button event listener
        const removeBtn = tr.querySelector('.remove-btn');
        removeBtn.addEventListener('click', () => {
            const stock = portfolio[stockIdx];
            const confirmMessage = `Are you sure you want to remove ${stock.ticker} from your portfolio?`;
            
            if (confirm(confirmMessage)) {
                portfolio.splice(stockIdx, 1);
                markPortfolioChanged(); // Mark as changed
                updatePortfolioTable();
                showStatus(`${stock.ticker} removed from portfolio`, 'info');
            }
        });
        
        // Date input event listener
        const dateInput = tr.querySelector('.edit-date');
        dateInput.addEventListener('change', (e) => {
            const newDate = e.target.value;
            portfolio[stockIdx].date = newDate;
            markPortfolioChanged(); // Mark as changed
            
            // Update prices asynchronously without blocking
            const ticker = portfolio[stockIdx].ticker;
            updateStockPricesAsync(ticker, newDate, stockIdx);
            
            updatePortfolioTable();
        });
        
        // Label management
        const labelsContainer = tr.querySelector('.labels-container');
        const labelPopup = tr.querySelector('.label-popup');
        const labelInput = tr.querySelector('.label-input');
        const addLabelBtn = tr.querySelector('.add-label-btn');
        const confirmBtn = tr.querySelector('.add-label-confirm');
        const cancelBtn = tr.querySelector('.cancel-label');
        
        // Show popup when clicking + button
        const showLabelPopup = (e) => {
            e.stopPropagation();
            const rect = labelsContainer.getBoundingClientRect();
            labelPopup.style.display = 'block';
            labelPopup.style.position = 'absolute';
            labelPopup.style.left = (rect.left + window.scrollX) + 'px';
            labelPopup.style.top = (rect.bottom + window.scrollY + 2) + 'px';
            labelInput.focus();
        };
        
        addLabelBtn.addEventListener('click', showLabelPopup);
        
        // Hide popup when clicking outside
        document.addEventListener('click', (e) => {
            if (!labelPopup.contains(e.target) && !labelsContainer.contains(e.target)) {
                labelPopup.style.display = 'none';
                labelInput.value = '';
            }
        });
        
        // Add label
        const addLabel = () => {
            const newLabel = labelInput.value.trim();
            if (newLabel && !portfolio[stockIdx].labels.includes(newLabel)) {
                portfolio[stockIdx].labels.push(newLabel);
                markPortfolioChanged(); // Mark as changed
                updatePortfolioTable();
            }
            labelPopup.style.display = 'none';
            labelInput.value = '';
        };
        
        confirmBtn.addEventListener('click', addLabel);
        labelInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addLabel();
            }
            if (e.key === 'Escape') {
                labelPopup.style.display = 'none';
                labelInput.value = '';
            }
        });
        
        // Cancel
        cancelBtn.addEventListener('click', () => {
            labelPopup.style.display = 'none';
            labelInput.value = '';
        });
        
        // Remove labels
        tr.querySelectorAll('.remove-label').forEach(removeBtn => {
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const labelToRemove = removeBtn.getAttribute('data-label');
                portfolio[stockIdx].labels = portfolio[stockIdx].labels.filter(l => l !== labelToRemove);
                markPortfolioChanged(); // Mark as changed
                updatePortfolioTable();
            });
        });
        
        // Notes editing with popup
        const notesDisplay = tr.querySelector('.notes-display');
        notesDisplay.addEventListener('click', () => {
            openNotesPopup(stockIdx);
        });
        
        // Ticker click to open Yahoo Finance
        const tickerCell = tr.querySelector('.ticker-cell');
        tickerCell.addEventListener('click', () => {
            window.open(`https://finance.yahoo.com/quote/${stock.ticker}`, '_blank');
        });
        
        portfolioTableBody.appendChild(tr);
    });
}

// Initialize everything after DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    const stockInput = document.getElementById('stock-input');
    const portfolioTableBody = document.getElementById('portfolio-tbody');
    
    if (!stockInput || !portfolioTableBody) {
        console.error('Required DOM elements not found');
        return;
    }
    
    // Ticker autocomplete
    stockInput.addEventListener('input', async (e) => {
        const val = e.target.value;
        if (val.length < 1) return;
        const suggestions = await fetchTickerSuggestions(val);
        const datalist = document.getElementById('ticker-list');
        datalist.innerHTML = '';
        suggestions.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.symbol;
            opt.label = s.name;
            datalist.appendChild(opt);
        });
    });
    
    // Add stock
    stockInput.addEventListener('change', (e) => {
        const ticker = stockInput.value.trim().toUpperCase();
        if (!ticker) {
            return;
        }
        
        // Clear input immediately for better UX
        stockInput.value = '';
        
        // Handle stock addition asynchronously without blocking
        addStockAsync(ticker);
    });
    
    // Label filter dropdown logic
    const labelHeader = document.getElementById('label-header');
    const dropdown = document.getElementById('label-filter-dropdown');
    
    if (labelHeader && dropdown) {
        labelHeader.addEventListener('click', (e) => {
            // Get unique labels
            const labels = Array.from(new Set(portfolio.flatMap(s => s.labels).filter(l => l)));
            
            // Position dropdown properly
            const rect = labelHeader.getBoundingClientRect();
            dropdown.style.left = rect.left + 'px';
            dropdown.style.top = (rect.bottom + 5) + 'px';
            
            dropdown.innerHTML = '';
            
            // Add "Select All" checkbox
            const selectAllDiv = document.createElement('div');
            selectAllDiv.style.marginBottom = '8px';
            selectAllDiv.style.borderBottom = '1px solid #ccc';
            selectAllDiv.style.paddingBottom = '5px';
            
            const selectAllId = 'label-filter-select-all';
            const allChecked = labels.length > 0 && labels.every(label => labelFilterSet.has(label));
            
            selectAllDiv.innerHTML = `<label><input type="checkbox" id="${selectAllId}" ${allChecked ? 'checked' : ''}> <strong>Select All</strong></label>`;
            dropdown.appendChild(selectAllDiv);
            
            // Add event listener for Select All
            selectAllDiv.querySelector('input').addEventListener('change', (ev) => {
                if (ev.target.checked) {
                    // Add all labels to filter set
                    labels.forEach(label => labelFilterSet.add(label));
                    // Check all checkboxes
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = true;
                    });
                } else {
                    // Clear filter set
                    labelFilterSet.clear();
                    // Uncheck all checkboxes
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = false;
                    });
                }
                updatePortfolioTable();
            });
            
            // Add individual label checkboxes
            labels.forEach(label => {
                const id = 'label-filter-' + label.replace(/\s+/g, '-');
                const div = document.createElement('div');
                div.innerHTML = `<label><input type="checkbox" id="${id}" value="${label}" ${labelFilterSet.has(label) ? 'checked' : ''}> ${label}</label>`;
                dropdown.appendChild(div);
                
                div.querySelector('input').addEventListener('change', (ev) => {
                    if (ev.target.checked) {
                        labelFilterSet.add(label);
                    } else {
                        labelFilterSet.delete(label);
                    }
                    
                    // Update Select All checkbox state
                    const allChecked = labels.length > 0 && labels.every(l => labelFilterSet.has(l));
                    const selectAllCheckbox = document.getElementById(selectAllId);
                    if (selectAllCheckbox) {
                        selectAllCheckbox.checked = allChecked;
                    }
                    
                    updatePortfolioTable();
                });
            });
            
            // Add Clear All button
            if (labels.length > 0) {
                const clearAllDiv = document.createElement('div');
                clearAllDiv.style.marginTop = '8px';
                clearAllDiv.style.borderTop = '1px solid #ccc';
                clearAllDiv.style.paddingTop = '5px';
                
                const clearButton = document.createElement('button');
                clearButton.innerText = 'Clear All';
                clearButton.style.padding = '3px 8px';
                clearButton.style.fontSize = '12px';
                
                clearButton.addEventListener('click', () => {
                    labelFilterSet.clear();
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = false;
                    });
                    updatePortfolioTable();
                });
                
                clearAllDiv.appendChild(clearButton);
                dropdown.appendChild(clearAllDiv);
            }
            
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
            e.stopPropagation();
        });
        
        document.body.addEventListener('click', () => {
            dropdown.style.display = 'none';
        });
        
        dropdown.addEventListener('click', (e) => e.stopPropagation());
    }
    
    // Add sort event listener
    const sortHeader = document.getElementById('sort-cumret');
    if (sortHeader) {
        sortHeader.addEventListener('click', () => {
            sortByCumulativeReturn = !sortByCumulativeReturn;
            updatePortfolioTable();
        });
    }

    // Initialize GitHub integration with a small delay to ensure DOM is ready
    setTimeout(() => {
        initializeGitHubIntegration();
    }, 100);

    // Initial render of portfolio
    updatePortfolioTable();
});

// Add before page unload warning
window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges) {
        const message = 'You have unsaved changes to your portfolio. Are you sure you want to leave?';
        e.preventDefault();
        e.returnValue = message;
        return message;
    }
});

// Add keyboard shortcut for force refresh (Ctrl+Shift+R or Cmd+Shift+R)
document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'R') {
        e.preventDefault();
        forceRefreshFromGitHub();
    }
});

// Force refresh from GitHub (clears cache)
async function forceRefreshFromGitHub() {
    try {
        showStatus('ðŸ”„ Force refreshing from GitHub (clearing cache)...', 'info');
        
        // Clear all caches
        if (window.githubClient) {
            window.githubClient.clearCache();
        }
        
        // Also clear browser cache for the current page
        if ('caches' in window) {
            const cacheNames = await caches.keys();
            await Promise.all(
                cacheNames.map(cacheName => caches.delete(cacheName))
            );
        }
        
        // Force reload from GitHub
        await loadPortfolioFromGitHub();
        
    } catch (error) {
        console.error('Force refresh error:', error);
        showStatus(`âŒ Force refresh failed: ${error.message}`, 'error');
    }
}

// GitHub Integration Functions
function showStatus(message, type = 'info') {
    const statusElement = document.getElementById('save-status');
    if (statusElement) {
        statusElement.textContent = message;
        statusElement.className = `status-message ${type}`;
        
        // Auto-hide success/info messages after 5 seconds
        if (type === 'success' || type === 'info') {
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 5000);
        }
    }
}

function updateGitHubUI() {
    const statusSection = document.getElementById('github-status');
    const saveButton = document.getElementById('save-portfolio');
    const githubInfo = document.getElementById('github-info');
    
    if (window.githubClient && window.githubClient.isAuthenticated()) {
        // Show status section when authenticated
        statusSection.style.display = 'block';
        saveButton.disabled = false;
        
        if (githubInfo) {
            githubInfo.textContent = `âœ… Connected to ${window.githubClient.repoOwner}/${window.githubClient.repoName}`;
        }
    } else {
        // Hide status section when not authenticated
        statusSection.style.display = 'none';
        saveButton.disabled = false; // Enable save button to allow triggering auth flow
    }
}

function initializeGitHubIntegration() {
    // Ensure GitHub client exists before proceeding
    if (!window.githubClient) {
        console.error('GitHub client not initialized');
        showStatus('GitHub integration failed to load', 'error');
        return;
    }
    
    console.log('Initializing GitHub integration...');
    
    // Update UI based on current auth status
    updateGitHubUI();
    updateSaveButtonState(); // Initialize save button state
    
    // Auto-load portfolio (works without authentication for public repos)
    console.log('Auto-loading portfolio from GitHub...');
    loadPortfolioFromGitHub().catch(error => {
        console.log('Auto-load failed (expected if no portfolio exists):', error.message);
        // Set initial hash for empty portfolio
        initialPortfolioHash = calculatePortfolioHash();
        markPortfolioSaved();
    });
    
    // Modal event handlers
    const authModal = document.getElementById('github-auth-modal');
    const closeModalBtn = document.getElementById('close-auth-modal');
    
    // Close modal when clicking X
    const closeModal = () => {
        if (authModal) {
            authModal.style.display = 'none';
            // Clear form
            const tokenInput = document.getElementById('github-token');
            if (tokenInput) tokenInput.value = '';
        }
    };
    
    if (closeModalBtn) closeModalBtn.addEventListener('click', closeModal);
    
    // Close modal when clicking outside of it
    if (authModal) {
        authModal.addEventListener('click', (e) => {
            if (e.target === authModal) {
                closeModal();
            }
        });
    }
    
    // GitHub authentication form
    const authForm = document.getElementById('github-auth-form');
    if (authForm) {
        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const token = document.getElementById('github-token').value.trim();
            const repoOwner = document.getElementById('repo-owner').value.trim();
            const repoName = document.getElementById('repo-name').value.trim();
            
            if (!token || !repoOwner || !repoName) {
                showStatus('Please fill in all fields', 'error');
                return;
            }
            
            try {
                // Test the authentication by making a simple API call
                showStatus('Testing GitHub connection...', 'info');
                
                window.githubClient.authenticate(token, repoOwner, repoName);
                
                // Test the connection
                await window.githubClient.getCurrentFileInfo();
                
                showStatus('Successfully connected to GitHub!', 'success');
                updateGitHubUI();
                
                // Clear the token field for security
                document.getElementById('github-token').value = '';
                
                // Close the authentication modal
                const authModal = document.getElementById('github-auth-modal');
                if (authModal) {
                    authModal.style.display = 'none';
                }
                
                // Automatically load portfolio after successful connection
                showStatus('Loading portfolio from GitHub...', 'info');
                try {
                    await loadPortfolioFromGitHub();
                } catch (loadError) {
                    console.error('Auto-load after auth error:', loadError);
                    showStatus('Connected to GitHub, but portfolio load failed. You can try saving to create the file.', 'info');
                }
                
            } catch (error) {
                console.error('GitHub auth error:', error);
                showStatus(`Authentication failed: ${error.message}`, 'error');
                window.githubClient.logout();
                updateGitHubUI();
            }
        });
    }
    
    // GitHub logout
    const logoutButton = document.getElementById('github-logout');
    if (logoutButton) {
        logoutButton.addEventListener('click', () => {
            window.githubClient.logout();
            updateGitHubUI();
            showStatus('Disconnected from GitHub', 'info');
        });
    }
    
    // Save button
    const saveButton = document.getElementById('save-portfolio');
    if (saveButton) {
        saveButton.addEventListener('click', (e) => {
            e.preventDefault();
            setTimeout(() => {
                savePortfolioToMarkdown()
                    .catch(error => console.error('Save error:', error));
            }, 0);
        });
    }
    
    // Refresh button
    const refreshButton = document.getElementById('refresh-portfolio');
    if (refreshButton) {
        refreshButton.addEventListener('click', (e) => {
            e.preventDefault();
            forceRefreshFromGitHub();
        });
    }
}

// Helper function to update individual stock data
async function updateStockData(stock) {
    try {
        // Fetch current price
        const currentPrice = await fetchCurrentPrice(stock.ticker);
        if (currentPrice !== null) {
            stock.nowPrice = currentPrice.toFixed(2);
        }
        
        // Fetch historical price and calculate return
        const historicalPrice = await fetchHistoricalPrice(stock.ticker, stock.date);
        if (historicalPrice !== null && currentPrice !== null) {
            const returnPercent = ((currentPrice - historicalPrice) / historicalPrice * 100);
            stock.cumulativeReturn = returnPercent.toFixed(2);
        }
        
        // Update the table (use debounced update to avoid excessive re-renders)
        debouncedUpdateTable();
        
    } catch (error) {
        console.error(`Error updating ${stock.ticker}:`, error);
        // Set fallback values on error
        if (!stock.nowPrice || stock.nowPrice === 'Loading...') {
            stock.nowPrice = 'Error';
        }
        if (!stock.cumulativeReturn || stock.cumulativeReturn === 'Calculating...') {
            stock.cumulativeReturn = 'Error';
        }
    }
}

// Async helper for adding stocks without blocking the event handler
async function addStockAsync(ticker) {
    try {
        // Validate ticker exists on Yahoo before adding
        const suggestions = await fetchTickerSuggestions(ticker);
        const matchedStock = suggestions.find(s => s.symbol.toUpperCase() === ticker);
        if (!matchedStock) {
            alert('Stock ticker not found. Please try again.');
            return;
        }
        
        const date = new Date().toISOString().slice(0,10);
        
        // Add stock immediately with loading state
        const stock = {
            ticker, 
            name: matchedStock.name || ticker,
            date, 
            labels: [], 
            notes: '',
            nowPrice: '...',
            cumulativeReturn: '...',
            starred: false,
            loading: true
        };
        portfolio.push(stock);
        markPortfolioChanged(); // Mark as changed
        updatePortfolioTable();
        
        // Then fetch prices asynchronously
        try {
            const startPrice = await fetchHistoricalPrice(ticker, date);
            const nowPrice = await fetchHistoricalPrice(ticker, new Date().toISOString().slice(0,10));
            
            // Find the stock again (in case portfolio changed)
            const stockIndex = portfolio.findIndex(s => s.ticker === ticker && s.loading);
            if (stockIndex !== -1) {
                if (startPrice != null && nowPrice != null) {
                    const cumulativeReturn = ((nowPrice - startPrice) / startPrice * 100).toFixed(2);
                    portfolio[stockIndex].nowPrice = Number(nowPrice).toFixed(2);
                    portfolio[stockIndex].cumulativeReturn = cumulativeReturn;
                } else {
                    portfolio[stockIndex].nowPrice = 'N/A';
                    portfolio[stockIndex].cumulativeReturn = 'N/A';
                }
                portfolio[stockIndex].loading = false;
                updatePortfolioTable();
                // Auto-save is disabled - user saves manually
            }
        } catch (error) {
            // Find the stock and mark as error
            const stockIndex = portfolio.findIndex(s => s.ticker === ticker && s.loading);
            if (stockIndex !== -1) {
                portfolio[stockIndex].nowPrice = 'Error';
                portfolio[stockIndex].cumulativeReturn = 'Error';
                portfolio[stockIndex].loading = false;
                updatePortfolioTable();
            }
        }
    } catch (error) {
        console.error('Error adding stock:', error);
        alert('Error adding stock. Please try again.');
    }
}

// Async helper for updating stock prices without blocking the event handler
function updateStockPricesAsync(ticker, newDate, stockIdx) {
    // Fire and forget - update prices in background
    Promise.all([
        fetchHistoricalPrice(ticker, newDate),
        fetchHistoricalPrice(ticker, new Date().toISOString().slice(0,10))
    ]).then(([startPrice, nowPrice]) => {
        if (portfolio[stockIdx]) {
            portfolio[stockIdx].nowPrice = nowPrice ? Number(nowPrice).toFixed(2) : 'N/A';
            portfolio[stockIdx].cumulativeReturn = (startPrice && nowPrice) ? 
                ((nowPrice - startPrice) / startPrice * 100).toFixed(2) : 'N/A';
            updatePortfolioTable();
        }
    }).catch(error => {
        console.error(`Error updating prices for ${ticker}:`, error);
        if (portfolio[stockIdx]) {
            portfolio[stockIdx].nowPrice = 'Error';
            portfolio[stockIdx].cumulativeReturn = 'Error';
            updatePortfolioTable();
        }
    });
}

// Notes popup functionality
let currentNotesStockIndex = null;

function openNotesPopup(stockIndex) {
    currentNotesStockIndex = stockIndex;
    const stock = portfolio[stockIndex];
    
    // Update popup title and content
    const popupTitle = document.getElementById('notes-popup-title');
    const textarea = document.getElementById('notes-textarea');
    const overlay = document.getElementById('notes-popup-overlay');
    
    popupTitle.textContent = `Notes for ${stock.ticker}`;
    textarea.value = stock.notes || '';
    
    // Show popup with animation
    overlay.style.display = 'flex';
    setTimeout(() => {
        overlay.classList.add('show');
        textarea.focus();
        textarea.select();
    }, 10);
}

function closeNotesPopup() {
    // Auto-save notes before closing
    if (currentNotesStockIndex !== null) {
        const textarea = document.getElementById('notes-textarea');
        portfolio[currentNotesStockIndex].notes = textarea.value;
        markPortfolioChanged();
        updatePortfolioTable();
    }
    
    const overlay = document.getElementById('notes-popup-overlay');
    overlay.classList.remove('show');
    
    setTimeout(() => {
        overlay.style.display = 'none';
        currentNotesStockIndex = null;
    }, 300);
}

// Initialize notes popup event listeners
document.addEventListener('DOMContentLoaded', () => {
    // Notes popup event listeners
    const notesOverlay = document.getElementById('notes-popup-overlay');
    const notesCloseBtn = document.getElementById('notes-popup-close');
    const notesTextarea = document.getElementById('notes-textarea');
    
    // Close popup when clicking overlay
    notesOverlay.addEventListener('click', (e) => {
        if (e.target === notesOverlay) {
            closeNotesPopup();
        }
    });
    
    // Close button
    notesCloseBtn.addEventListener('click', closeNotesPopup);
    
    // Keyboard shortcuts
    notesTextarea.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeNotesPopup();
        }
    });
});
