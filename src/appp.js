// Helper: Fetch ticker suggestions from Yahoo Finance
async function fetchTickerSuggestions(query) {
    if (!query) return [];
    const CORS_PROXY = 'https://corsproxy.io/?';
    const url = CORS_PROXY + `https://query1.finance.yahoo.com/v1/finance/search?q=${encodeURIComponent(query)}&quotesCount=5&newsCount=0`;
    try {
        const res = await fetch(url);
        const data = await res.json();
        return (data.quotes || []).map(q => ({symbol: q.symbol, name: q.shortname || q.longname || q.symbol}));
    } catch (e) {
        return [];
    }
}

// Global variables
let portfolio = [];
let sortByCumulativeReturn = false;
let labelFilterSet = new Set();
let tableUpdateTimeout = null;

// Debounced table update to prevent excessive re-renders
function debouncedUpdateTable() {
    if (tableUpdateTimeout) {
        clearTimeout(tableUpdateTimeout);
    }
    tableUpdateTimeout = setTimeout(() => {
        updatePortfolioTable();
    }, 100);
}

// Fetch historical price from Yahoo
async function fetchHistoricalPrice(ticker, date) {
    const targetDate = new Date(date);
    const start = Math.floor(targetDate.getTime() / 1000);
    
    // Add extra days to handle weekends and holidays - look back up to 7 days
    const endDate = new Date(targetDate.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days later
    const end = Math.floor(endDate.getTime() / 1000);
    
    const CORS_PROXY = 'https://corsproxy.io/?';
    const url = CORS_PROXY + `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?period1=${start}&period2=${end}&interval=1d`;
    try {
        const res = await fetch(url);
        const data = await res.json();
        
        // Defensive checks for missing data
        if (
            !data.chart ||
            !data.chart.result ||
            !data.chart.result[0] ||
            !data.chart.result[0].indicators ||
            !data.chart.result[0].indicators.quote[0] ||
            !data.chart.result[0].indicators.quote[0].close
        ) {
            return null;
        }
        
        const prices = data.chart.result[0].indicators.quote[0].close;
        const timestamps = data.chart.result[0].timestamp;
        
        if (!prices || !timestamps || prices.length === 0) {
            return null;
        }
        
        // Find the first valid price on or after the target date
        for (let i = 0; i < timestamps.length; i++) {
            const priceDate = new Date(timestamps[i] * 1000);
            if (priceDate >= targetDate && prices[i] != null) {
                return prices[i];
            }
        }
        
        // If no price found on or after target date, use the last available price
        for (let i = prices.length - 1; i >= 0; i--) {
            if (prices[i] != null) {
                return prices[i];
            }
        }
        
        return null;
    } catch (e) {
        return null;
    }
}

// Fetch current price from Yahoo Finance
async function fetchCurrentPrice(ticker) {
    const CORS_PROXY = 'https://corsproxy.io/?';
    const url = CORS_PROXY + `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?range=1d&interval=1m`;
    try {
        const res = await fetch(url);
        const data = await res.json();
        // Get the most recent price
        if (
            data.chart &&
            data.chart.result &&
            data.chart.result[0] &&
            data.chart.result[0].meta &&
            data.chart.result[0].meta.regularMarketPrice
        ) {
            return data.chart.result[0].meta.regularMarketPrice;
        }
        return null;
    } catch (e) {
        return null;
    }
}

// Save portfolio to markdown and upload to GitHub
async function savePortfolioToMarkdown() {
    if (!window.githubClient || !window.githubClient.isAuthenticated()) {
        showStatus('Please authenticate with GitHub first', 'error');
        return;
    }

    try {
        showStatus('Saving to GitHub...', 'info');
        
        // Generate markdown content
        let md = '# Portfolio\n\n';
        md += `Last updated: ${new Date().toISOString()}\n\n`;
        md += '| Ticker | Date | Labels | Notes |\n';
        md += '|--------|------|--------|---------|\n';
        
        portfolio.forEach(s => {
            const labels = s.labels.join(', ');
            const notes = s.notes.replace(/\|/g, '\\|'); // Escape pipes in notes
            md += `| ${s.ticker} | ${s.date} | ${labels} | ${notes} |\n`;
        });
        
        md += `\n---\n*Generated by Stock Tracker - ${portfolio.length} stocks tracked*\n`;
        
        // Save to GitHub
        const result = await window.githubClient.saveFile(md, `Update portfolio - ${portfolio.length} stocks`);
        showStatus(result.message, 'success');
        
    } catch (error) {
        console.error('Save error:', error);
        showStatus(`Save failed: ${error.message}`, 'error');
    }
}

// Load portfolio from GitHub
async function loadPortfolioFromGitHub() {
    if (!window.githubClient || !window.githubClient.isAuthenticated()) {
        showStatus('Please authenticate with GitHub first', 'error');
        return;
    }

    try {
        showStatus('Loading from GitHub...', 'info');
        
        // Break up the work - first get the file
        const result = await window.githubClient.loadFile();
        
        if (!result.exists) {
            showStatus('No portfolio file found on GitHub', 'info');
            return;
        }
        
        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 0));
        
        showStatus('Parsing portfolio data...', 'info');
        
        // Parse the markdown content in chunks
        const portfolioData = await parseMarkdownContent(result.content);
        
        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 0));
        
        // Merge with existing portfolio (keep starred status from local data)
        const existingStarred = new Map(portfolio.map(s => [s.ticker, s.starred]));
        portfolio = portfolioData.map(stock => ({
            ...stock,
            starred: existingStarred.get(stock.ticker) || false
        }));
        
        // Refresh the table immediately with the loaded data
        updatePortfolioTable();
        
        showStatus(`Portfolio loaded: ${portfolio.length} stocks. Updating prices...`, 'info');
        
        // Allow UI to update before starting price updates
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Fetch fresh data for all stocks asynchronously to avoid blocking
        updateAllStockDataAsync(portfolio);
        
    } catch (error) {
        console.error('Load error:', error);
        showStatus(`Load failed: ${error.message}`, 'error');
    }
}

// Separate function to parse markdown content
async function parseMarkdownContent(content) {
    console.log('Parsing markdown content:', content.substring(0, 200) + '...');
    
    const lines = content.split('\n');
    const portfolioData = [];
    let inTable = false;
    let tableFormat = 'new'; // 'new' or 'old'
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        // Allow UI to breathe every 50 lines
        if (i % 50 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
        
        // Detect table header - support multiple formats
        if (line.startsWith('|') && (line.includes('Ticker') || line.includes('Stock Symbol'))) {
            console.log('Found table header at line', i, ':', line);
            inTable = true;
            
            // Determine table format
            if (line.includes('Stock Symbol')) {
                tableFormat = 'old'; // Legacy 5-column format
                console.log('Using old table format');
            } else if (line.includes('Current Price') || line.includes('Return')) {
                tableFormat = 'six-column'; // 6-column format with dynamic data
                console.log('Using six-column table format');
            } else {
                tableFormat = 'new'; // New simplified 4-column format
                console.log('Using new simplified table format');
            }
            continue;
        }
        
        if (line.startsWith('|-----')) {
            console.log('Found table separator at line', i);
            continue;
        }
        
        if (inTable && line.startsWith('|') && !line.startsWith('|---')) {
            console.log('Processing table row at line', i, ':', line);
            // Don't filter out empty columns - we need to preserve column positions
            const columns = line.split('|').map(col => col.trim()).slice(1, -1); // Remove first and last empty elements
            console.log('Columns found:', columns);
            
            // Skip completely empty rows or rows with only empty/whitespace columns
            if (columns.every(col => col === '' || col === ' ')) {
                console.log('Skipping empty row');
                continue;
            }
            
            // Skip rows that look like template rows (all spaces or dashes)
            if (columns.every(col => /^[\s-]*$/.test(col))) {
                console.log('Skipping template/placeholder row');
                continue;
            }
            
            let ticker, date, labels, notes;
            
            if (tableFormat === 'old' && columns.length >= 5) {
                // Old format: Stock Symbol | Date Added | Cumulative Return | Label | Notes
                [ticker, date, , labels, notes] = columns; // Skip return column
            } else if (tableFormat === 'six-column' && columns.length >= 4) {
                // Six-column format: Ticker | Date | Labels | Notes | Current Price | Return (%)
                // Handle missing columns gracefully, ignore price and return
                ticker = columns[0] || '';
                date = columns[1] || '';
                labels = columns[2] || '';
                notes = columns[3] || '';
                // Ignore columns[4] (price) and columns[5] (return)
            } else if (tableFormat === 'new' && columns.length >= 4) {
                // New simplified format: Ticker | Date | Labels | Notes
                ticker = columns[0] || '';
                date = columns[1] || '';
                labels = columns[2] || '';
                notes = columns[3] || '';
            } else {
                console.log('Skipping row - wrong number of columns for format:', tableFormat, columns.length);
                continue;
            }
            
            // Additional validation: make sure ticker and date have actual content
            if (ticker && ticker !== 'Ticker' && ticker !== 'Stock Symbol' && 
                date && date !== 'Date' && date !== 'Date Added' &&
                ticker.trim() !== '' && date.trim() !== '') {
                console.log('Adding stock:', ticker, date);
                portfolioData.push({
                    ticker: ticker,
                    date: date,
                    labels: labels ? labels.split(',').map(l => l.trim()).filter(l => l) : [],
                    notes: notes ? notes.replace(/\\|/g, '|') : '', // Unescape pipes
                    nowPrice: 'Loading...', // Always start fresh - don't save/load dynamic data
                    cumulativeReturn: 'Calculating...', // Always start fresh - don't save/load dynamic data
                    starred: false // Will be set based on local data if exists
                });
            } else {
                console.log('Skipping row - invalid or empty ticker/date:', ticker, date);
            }
        }
        
        if (inTable && !line.startsWith('|')) {
            console.log('End of table at line', i);
            inTable = false;
        }
    }
    
    console.log('Portfolio data parsed:', portfolioData.length, 'stocks');
    return portfolioData;
}

// Asynchronously update all stock data with progress feedback
async function updateAllStockDataAsync(stocks) {
    if (!stocks || stocks.length === 0) return;
    
    let completed = 0;
    const total = stocks.length;
    
    // Process stocks in batches to avoid overwhelming the API
    const batchSize = 3;
    
    for (let i = 0; i < stocks.length; i += batchSize) {
        const batch = stocks.slice(i, i + batchSize);
        
        // Process batch in parallel
        const promises = batch.map(async (stock, index) => {
            try {
                await updateStockData(stock);
                completed++;
                
                // Update status every few completions
                if (completed % 2 === 0 || completed === total) {
                    showStatus(`Updated ${completed}/${total} stocks...`, 'info');
                }
            } catch (error) {
                console.error(`Error updating ${stock.ticker}:`, error);
                completed++;
            }
        });
        
        await Promise.all(promises);
        
        // Small delay between batches to be nice to the API
        if (i + batchSize < stocks.length) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    showStatus(`All ${total} stocks updated successfully!`, 'success');
}

// Render portfolio
function updatePortfolioTable() {
    const portfolioTableBody = document.getElementById('portfolio-tbody');
    if (!portfolioTableBody) return;

    // Clear the table
    portfolioTableBody.innerHTML = '';
    
    // Sort: starred first, then by cumulative return if requested
    let sorted = [...portfolio];
    sorted.sort((a, b) => {
        if (a.starred && !b.starred) return -1;
        if (!a.starred && b.starred) return 1;
        if (sortByCumulativeReturn) {
            const aVal = parseFloat(a.cumulativeReturn) || -Infinity;
            const bVal = parseFloat(b.cumulativeReturn) || -Infinity;
            return bVal - aVal;
        }
        return 0;
    });
    
    // Filter by label if any selected
    let filtered = sorted;
    if (labelFilterSet.size > 0) {
        filtered = sorted.filter(stock => stock.labels.some(label => labelFilterSet.has(label)));
    }
    
    // Create and append rows with event listeners
    filtered.forEach(stock => {
        const tr = document.createElement('tr');
        const notesShort = stock.notes && stock.notes.length > 20 ? stock.notes.slice(0, 20) + '‚Ä¶' : stock.notes;
        const stockIdx = portfolio.indexOf(stock);
        
        tr.innerHTML = `
            <td style="text-align:center;"><button class="star-btn" data-idx="${stockIdx}">${stock.starred ? '‚òÖ' : '‚òÜ'}</button></td>
            <td style="text-align:center;">
                <div class="ticker-cell" style="cursor:pointer;" data-ticker="${stock.ticker}">
                    <div style="font-weight:bold; color:#0066cc;">${stock.ticker}</div>
                    <div style="font-size:11px; color:#666; margin-top:2px;">${stock.name || ''}</div>
                </div>
            </td>
            <td style="text-align:center;"><input type="date" value="${stock.date}" data-idx="${stockIdx}" class="edit-date" style="width:130px;"></td>
            <td style="text-align:center;">
                <div class="labels-container" data-idx="${stockIdx}" style="cursor:pointer; min-width:80px; padding:4px; border:1px solid transparent;">
                    ${stock.labels.map(label => `<span class="label-tag" style="display:inline-block; background:#e3f2fd; color:#1976d2; padding:2px 6px; margin:1px; border-radius:3px; font-size:11px;">${label}<span class="remove-label" data-label="${label}" style="margin-left:4px; cursor:pointer; font-weight:bold;">√ó</span></span>`).join('')}
                    ${stock.labels.length === 0 ? '<span class="add-label-prompt" style="color:#888;">Click to add</span>' : ''}
                    <span class="add-label-btn" style="display:inline-block; background:#f0f0f0; color:#666; padding:2px 6px; margin:1px; border-radius:3px; font-size:11px; cursor:pointer;">+</span>
                </div>
                <div class="label-popup" data-idx="${stockIdx}" style="display:none; position:absolute; background:white; border:1px solid #ccc; border-radius:4px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:1000;">
                    <input type="text" class="label-input" placeholder="Add label" style="width:120px; padding:4px; margin-bottom:8px; border:1px solid #ccc; border-radius:3px;">
                    <div>
                        <button class="add-label-confirm" style="padding:4px 8px; margin-right:4px; background:#4caf50; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">Add</button>
                        <button class="cancel-label" style="padding:4px 8px; background:#f44336; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">Cancel</button>
                    </div>
                </div>
            </td>
            <td style="text-align:center;">
                <span class="notes-popup" data-full="${encodeURIComponent(stock.notes)}" data-idx="${stockIdx}" style="cursor:pointer; display:inline-block; min-width:80px; padding:4px; border:1px solid transparent;">${notesShort || 'Click to add'}</span>
                <input type="text" value="${stock.notes}" data-idx="${stockIdx}" class="edit-notes" style="display:none;width:120px;">
            </td>
            <td style="text-align:right;">${stock.nowPrice != null ? (stock.loading ? '...' : '$' + stock.nowPrice) : ''}</td>
            <td class="cumulative-return" style="text-align:right;">${stock.loading ? '...' : stock.cumulativeReturn}</td>
            <td style="text-align:center;"><button class="remove-btn" data-idx="${stockIdx}" style="background:#f44336; color:white; border:none; border-radius:3px; cursor:pointer; padding:4px 8px; font-size:11px;">üóëÔ∏è</button></td>
        `;
        
        // Star button event listener
        const starBtn = tr.querySelector('.star-btn');
        starBtn.addEventListener('click', () => {
            portfolio[stockIdx].starred = !portfolio[stockIdx].starred;
            updatePortfolioTable();
            // Portfolio will be saved manually using the save button
        });
        
        // Remove button event listener
        const removeBtn = tr.querySelector('.remove-btn');
        removeBtn.addEventListener('click', () => {
            const stock = portfolio[stockIdx];
            const confirmMessage = `Are you sure you want to remove ${stock.ticker} from your portfolio?`;
            
            if (confirm(confirmMessage)) {
                portfolio.splice(stockIdx, 1);
                updatePortfolioTable();
                showStatus(`${stock.ticker} removed from portfolio`, 'info');
                // Portfolio will be saved manually using the save button
            }
        });
        
        // Date input event listener
        const dateInput = tr.querySelector('.edit-date');
        dateInput.addEventListener('change', (e) => {
            const newDate = e.target.value;
            portfolio[stockIdx].date = newDate;
            
            // Update prices asynchronously without blocking
            const ticker = portfolio[stockIdx].ticker;
            updateStockPricesAsync(ticker, newDate, stockIdx);
            
            updatePortfolioTable();
            // Portfolio will be saved manually using the save button
        });
        
        // Label management
        const labelsContainer = tr.querySelector('.labels-container');
        const labelPopup = tr.querySelector('.label-popup');
        const labelInput = tr.querySelector('.label-input');
        const addLabelBtn = tr.querySelector('.add-label-btn');
        const addLabelPrompt = tr.querySelector('.add-label-prompt');
        const confirmBtn = tr.querySelector('.add-label-confirm');
        const cancelBtn = tr.querySelector('.cancel-label');
        
        // Show popup when clicking container or + button
        const showLabelPopup = (e) => {
            e.stopPropagation();
            const rect = labelsContainer.getBoundingClientRect();
            labelPopup.style.display = 'block';
            labelPopup.style.position = 'absolute';
            labelPopup.style.left = (rect.left + window.scrollX) + 'px';
            labelPopup.style.top = (rect.bottom + window.scrollY + 2) + 'px';
            labelInput.focus();
        };
        
        if (addLabelPrompt) addLabelPrompt.addEventListener('click', showLabelPopup);
        addLabelBtn.addEventListener('click', showLabelPopup);
        
        // Hide popup when clicking outside
        document.addEventListener('click', (e) => {
            if (!labelPopup.contains(e.target) && !labelsContainer.contains(e.target)) {
                labelPopup.style.display = 'none';
                labelInput.value = '';
            }
        });
        
        // Add label
        const addLabel = () => {
            const newLabel = labelInput.value.trim();
            if (newLabel && !portfolio[stockIdx].labels.includes(newLabel)) {
                portfolio[stockIdx].labels.push(newLabel);
                updatePortfolioTable();
                // Portfolio will be saved manually using the save button
            }
            labelPopup.style.display = 'none';
            labelInput.value = '';
        };
        
        confirmBtn.addEventListener('click', addLabel);
        labelInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addLabel();
            }
            if (e.key === 'Escape') {
                labelPopup.style.display = 'none';
                labelInput.value = '';
            }
        });
        
        // Cancel
        cancelBtn.addEventListener('click', () => {
            labelPopup.style.display = 'none';
            labelInput.value = '';
        });
        
        // Remove labels
        tr.querySelectorAll('.remove-label').forEach(removeBtn => {
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const labelToRemove = removeBtn.getAttribute('data-label');
                portfolio[stockIdx].labels = portfolio[stockIdx].labels.filter(l => l !== labelToRemove);
                updatePortfolioTable();
                // Portfolio will be saved manually using the save button
            });
        });
        
        // Notes editing with popup
        const notesSpan = tr.querySelector('.notes-popup');
        const notesInput = tr.querySelector('.edit-notes');


        notesSpan.addEventListener('click', () => {
            notesSpan.style.display = 'none';
            notesInput.style.display = 'inline-block';
            notesInput.focus();
            notesInput.select();
        });
        
        notesInput.addEventListener('blur', () => {
            portfolio[stockIdx].notes = notesInput.value;
            notesSpan.style.display = 'inline-block';
            notesInput.style.display = 'none';
            updatePortfolioTable();
            // Portfolio will be saved manually using the save button
        });
        
        notesInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                notesInput.blur();
            }
            if (e.key === 'Escape') {
                notesInput.value = stock.notes;
                notesInput.blur();
            }
        });
        
        // Ticker click to open Yahoo Finance
        const tickerCell = tr.querySelector('.ticker-cell');
        tickerCell.addEventListener('click', () => {
            window.open(`https://finance.yahoo.com/quote/${stock.ticker}`, '_blank');
        });
        
        portfolioTableBody.appendChild(tr);
    });
}

// Initialize everything after DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    const stockInput = document.getElementById('stock-input');
    const portfolioTableBody = document.getElementById('portfolio-tbody');
    
    if (!stockInput || !portfolioTableBody) {
        console.error('Required DOM elements not found');
        return;
    }
    
    // Ticker autocomplete
    stockInput.addEventListener('input', async (e) => {
        const val = e.target.value;
        if (val.length < 1) return;
        const suggestions = await fetchTickerSuggestions(val);
        const datalist = document.getElementById('ticker-list');
        datalist.innerHTML = '';
        suggestions.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.symbol;
            opt.label = s.name;
            datalist.appendChild(opt);
        });
    });
    
    // Add stock
    stockInput.addEventListener('change', (e) => {
        const ticker = stockInput.value.trim().toUpperCase();
        if (!ticker) {
            return;
        }
        
        // Clear input immediately for better UX
        stockInput.value = '';
        
        // Handle stock addition asynchronously without blocking
        addStockAsync(ticker);
    });
    
    // Label filter dropdown logic
    const labelHeader = document.getElementById('label-header');
    const dropdown = document.getElementById('label-filter-dropdown');
    
    if (labelHeader && dropdown) {
        labelHeader.addEventListener('click', (e) => {
            // Get unique labels
            const labels = Array.from(new Set(portfolio.flatMap(s => s.labels).filter(l => l)));
            
            // Position dropdown properly
            const rect = labelHeader.getBoundingClientRect();
            dropdown.style.left = rect.left + 'px';
            dropdown.style.top = (rect.bottom + 5) + 'px';
            
            dropdown.innerHTML = '';
            
            // Add "Select All" checkbox
            const selectAllDiv = document.createElement('div');
            selectAllDiv.style.marginBottom = '8px';
            selectAllDiv.style.borderBottom = '1px solid #ccc';
            selectAllDiv.style.paddingBottom = '5px';
            
            const selectAllId = 'label-filter-select-all';
            const allChecked = labels.length > 0 && labels.every(label => labelFilterSet.has(label));
            
            selectAllDiv.innerHTML = `<label><input type="checkbox" id="${selectAllId}" ${allChecked ? 'checked' : ''}> <strong>Select All</strong></label>`;
            dropdown.appendChild(selectAllDiv);
            
            // Add event listener for Select All
            selectAllDiv.querySelector('input').addEventListener('change', (ev) => {
                if (ev.target.checked) {
                    // Add all labels to filter set
                    labels.forEach(label => labelFilterSet.add(label));
                    // Check all checkboxes
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = true;
                    });
                } else {
                    // Clear filter set
                    labelFilterSet.clear();
                    // Uncheck all checkboxes
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = false;
                    });
                }
                updatePortfolioTable();
            });
            
            // Add individual label checkboxes
            labels.forEach(label => {
                const id = 'label-filter-' + label.replace(/\s+/g, '-');
                const div = document.createElement('div');
                div.innerHTML = `<label><input type="checkbox" id="${id}" value="${label}" ${labelFilterSet.has(label) ? 'checked' : ''}> ${label}</label>`;
                dropdown.appendChild(div);
                
                div.querySelector('input').addEventListener('change', (ev) => {
                    if (ev.target.checked) {
                        labelFilterSet.add(label);
                    } else {
                        labelFilterSet.delete(label);
                    }
                    
                    // Update Select All checkbox state
                    const allChecked = labels.length > 0 && labels.every(l => labelFilterSet.has(l));
                    const selectAllCheckbox = document.getElementById(selectAllId);
                    if (selectAllCheckbox) {
                        selectAllCheckbox.checked = allChecked;
                    }
                    
                    updatePortfolioTable();
                });
            });
            
            // Add Clear All button
            if (labels.length > 0) {
                const clearAllDiv = document.createElement('div');
                clearAllDiv.style.marginTop = '8px';
                clearAllDiv.style.borderTop = '1px solid #ccc';
                clearAllDiv.style.paddingTop = '5px';
                
                const clearButton = document.createElement('button');
                clearButton.innerText = 'Clear All';
                clearButton.style.padding = '3px 8px';
                clearButton.style.fontSize = '12px';
                
                clearButton.addEventListener('click', () => {
                    labelFilterSet.clear();
                    dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = false;
                    });
                    updatePortfolioTable();
                });
                
                clearAllDiv.appendChild(clearButton);
                dropdown.appendChild(clearAllDiv);
            }
            
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
            e.stopPropagation();
        });
        
        document.body.addEventListener('click', () => {
            dropdown.style.display = 'none';
        });
        
        dropdown.addEventListener('click', (e) => e.stopPropagation());
    }
    
    // Add sort event listener
    const sortHeader = document.getElementById('sort-cumret');
    if (sortHeader) {
        sortHeader.addEventListener('click', () => {
            sortByCumulativeReturn = !sortByCumulativeReturn;
            updatePortfolioTable();
        });
    }

    // Initialize GitHub integration with a small delay to ensure DOM is ready
    setTimeout(() => {
        initializeGitHubIntegration();
    }, 100);

    // Initial render of portfolio
    updatePortfolioTable();
});

// GitHub Integration Functions
function showStatus(message, type = 'info') {
    const statusElement = document.getElementById('save-status');
    if (statusElement) {
        statusElement.textContent = message;
        statusElement.className = `status-message ${type}`;
        
        // Auto-hide success/info messages after 5 seconds
        if (type === 'success' || type === 'info') {
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 5000);
        }
    }
}

function updateGitHubUI() {
    const loginSection = document.getElementById('github-login');
    const statusSection = document.getElementById('github-status');
    const saveButton = document.getElementById('save-portfolio');
    const githubInfo = document.getElementById('github-info');
    
    if (window.githubClient && window.githubClient.isAuthenticated()) {
        loginSection.style.display = 'none';
        statusSection.style.display = 'block';
        saveButton.disabled = false;
        
        if (githubInfo) {
            githubInfo.textContent = `‚úÖ Connected to ${window.githubClient.repoOwner}/${window.githubClient.repoName}`;
        }
    } else {
        loginSection.style.display = 'block';
        statusSection.style.display = 'none';
        saveButton.disabled = true;
    }
}

function initializeGitHubIntegration() {
    // Ensure GitHub client exists before proceeding
    if (!window.githubClient) {
        console.error('GitHub client not initialized');
        showStatus('GitHub integration failed to load', 'error');
        return;
    }
    
    console.log('Initializing GitHub integration...');
    
    // Update UI based on current auth status
    updateGitHubUI();
    
    // If already authenticated, automatically load portfolio from GitHub
    if (window.githubClient && window.githubClient.isAuthenticated()) {
        console.log('User already authenticated, auto-loading portfolio...');
        showStatus('Auto-loading portfolio from GitHub...', 'info');
        loadPortfolioFromGitHub().catch(error => {
            console.error('Auto-load error:', error);
            showStatus('Auto-load failed, continuing with local data', 'info');
        });
    } else {
        console.log('User not authenticated, showing login form');
    }
    
    // GitHub authentication form
    const authForm = document.getElementById('github-auth-form');
    if (authForm) {
        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const token = document.getElementById('github-token').value.trim();
            const repoOwner = document.getElementById('repo-owner').value.trim();
            const repoName = document.getElementById('repo-name').value.trim();
            
            if (!token || !repoOwner || !repoName) {
                showStatus('Please fill in all fields', 'error');
                return;
            }
            
            try {
                // Test the authentication by making a simple API call
                showStatus('Testing GitHub connection...', 'info');
                
                window.githubClient.authenticate(token, repoOwner, repoName);
                
                // Test the connection
                await window.githubClient.getCurrentFileInfo();
                
                showStatus('Successfully connected to GitHub!', 'success');
                updateGitHubUI();
                
                // Clear the token field for security
                document.getElementById('github-token').value = '';
                
                // Automatically load portfolio after successful connection
                showStatus('Loading portfolio from GitHub...', 'info');
                try {
                    await loadPortfolioFromGitHub();
                } catch (loadError) {
                    console.error('Auto-load after auth error:', loadError);
                    showStatus('Connected to GitHub, but portfolio load failed. You can try saving to create the file.', 'info');
                }
                
            } catch (error) {
                console.error('GitHub auth error:', error);
                showStatus(`Authentication failed: ${error.message}`, 'error');
                window.githubClient.logout();
                updateGitHubUI();
            }
        });
    }
    
    // GitHub logout
    const logoutButton = document.getElementById('github-logout');
    if (logoutButton) {
        logoutButton.addEventListener('click', () => {
            window.githubClient.logout();
            updateGitHubUI();
            showStatus('Disconnected from GitHub', 'info');
        });
    }
    
    // Save button
    const saveButton = document.getElementById('save-portfolio');
    if (saveButton) {
        saveButton.addEventListener('click', (e) => {
            // Disable button immediately
            saveButton.disabled = true;
            saveButton.textContent = 'üíæ Saving...';
            
            // Fire and forget - handle result in callback
            savePortfolioAsync()
                .then(() => {
                    // Success handled in savePortfolioToMarkdown
                })
                .catch((error) => {
                    console.error('Save error:', error);
                    showStatus(`Save failed: ${error.message}`, 'error');
                })
                .finally(() => {
                    const btn = document.getElementById('save-portfolio');
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'üíæ Save to GitHub';
                    }
                });
        });
    }

    // Async function that doesn't block
    function savePortfolioAsync() {
        return savePortfolioToMarkdown();
    }
}

// Helper function to update individual stock data
async function updateStockData(stock) {
    try {
        // Fetch current price
        const currentPrice = await fetchCurrentPrice(stock.ticker);
        if (currentPrice !== null) {
            stock.nowPrice = currentPrice.toFixed(2);
        }
        
        // Fetch historical price and calculate return
        const historicalPrice = await fetchHistoricalPrice(stock.ticker, stock.date);
        if (historicalPrice !== null && currentPrice !== null) {
            const returnPercent = ((currentPrice - historicalPrice) / historicalPrice * 100);
            stock.cumulativeReturn = returnPercent.toFixed(2);
        }
        
        // Update the table (use debounced update to avoid excessive re-renders)
        debouncedUpdateTable();
        
    } catch (error) {
        console.error(`Error updating ${stock.ticker}:`, error);
        // Set fallback values on error
        if (!stock.nowPrice || stock.nowPrice === 'Loading...') {
            stock.nowPrice = 'Error';
        }
        if (!stock.cumulativeReturn || stock.cumulativeReturn === 'Calculating...') {
            stock.cumulativeReturn = 'Error';
        }
    }
}

// Async helper for adding stocks without blocking the event handler
async function addStockAsync(ticker) {
    try {
        // Validate ticker exists on Yahoo before adding
        const suggestions = await fetchTickerSuggestions(ticker);
        const matchedStock = suggestions.find(s => s.symbol.toUpperCase() === ticker);
        if (!matchedStock) {
            alert('Stock ticker not found. Please try again.');
            return;
        }
        
        const date = new Date().toISOString().slice(0,10);
        
        // Add stock immediately with loading state
        const stock = {
            ticker, 
            name: matchedStock.name || ticker,
            date, 
            labels: [], 
            notes: '',
            nowPrice: '...',
            cumulativeReturn: '...',
            starred: false,
            loading: true
        };
        portfolio.push(stock);
        updatePortfolioTable();
        
        // Then fetch prices asynchronously
        try {
            const startPrice = await fetchHistoricalPrice(ticker, date);
            const nowPrice = await fetchHistoricalPrice(ticker, new Date().toISOString().slice(0,10));
            
            // Find the stock again (in case portfolio changed)
            const stockIndex = portfolio.findIndex(s => s.ticker === ticker && s.loading);
            if (stockIndex !== -1) {
                if (startPrice != null && nowPrice != null) {
                    const cumulativeReturn = ((nowPrice - startPrice) / startPrice * 100).toFixed(2);
                    portfolio[stockIndex].nowPrice = Number(nowPrice).toFixed(2);
                    portfolio[stockIndex].cumulativeReturn = cumulativeReturn;
                } else {
                    portfolio[stockIndex].nowPrice = 'N/A';
                    portfolio[stockIndex].cumulativeReturn = 'N/A';
                }
                portfolio[stockIndex].loading = false;
                updatePortfolioTable();
                // Auto-save is disabled - user saves manually
            }
        } catch (error) {
            // Find the stock and mark as error
            const stockIndex = portfolio.findIndex(s => s.ticker === ticker && s.loading);
            if (stockIndex !== -1) {
                portfolio[stockIndex].nowPrice = 'Error';
                portfolio[stockIndex].cumulativeReturn = 'Error';
                portfolio[stockIndex].loading = false;
                updatePortfolioTable();
            }
        }
    } catch (error) {
        console.error('Error adding stock:', error);
        alert('Error adding stock. Please try again.');
    }
}

// Async helper for updating stock prices without blocking the event handler
function updateStockPricesAsync(ticker, newDate, stockIdx) {
    // Fire and forget - update prices in background
    Promise.all([
        fetchHistoricalPrice(ticker, newDate),
        fetchHistoricalPrice(ticker, new Date().toISOString().slice(0,10))
    ]).then(([startPrice, nowPrice]) => {
        if (portfolio[stockIdx]) {
            portfolio[stockIdx].nowPrice = nowPrice ? Number(nowPrice).toFixed(2) : 'N/A';
            portfolio[stockIdx].cumulativeReturn = (startPrice && nowPrice) ? 
                ((nowPrice - startPrice) / startPrice * 100).toFixed(2) : 'N/A';
            updatePortfolioTable();
        }
    }).catch(error => {
        console.error(`Error updating prices for ${ticker}:`, error);
        if (portfolio[stockIdx]) {
            portfolio[stockIdx].nowPrice = 'Error';
            portfolio[stockIdx].cumulativeReturn = 'Error';
            updatePortfolioTable();
        }
    });
}
