/**
 * Portfolio data management
 */
let portfolio = [];
let hasUnsavedChanges = false;
let sortByCumulativeReturn = false;
let sortBy3MonthReturn = false;
let labelFilterSet = new Set();
let showZeroStarStocks = false;

function markChanged() {
    hasUnsavedChanges = true;
    updateSaveButtonState();
    if (!document.title.startsWith('*')) document.title = '* Stock Tracker';
}

function markSaved() {
    hasUnsavedChanges = false;
    updateSaveButtonState();
    document.title = 'Stock Tracker';
}

/** Generate portfolio HTML for GitHub storage */
function generateHtml() {
    const ts = new Date().toISOString();
    const rows = portfolio.map(s => {
        const notes = (s.notes || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const name = (s.name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const r = s.rating || 0;
        return `      <tr><td>${s.ticker}</td><td>${name}</td><td>${s.date}</td><td>${s.labels.join(', ')}</td><td>${notes}</td><td><span class="star">${'★'.repeat(r)}${'☆'.repeat(5 - r)}</span> (${r})</td></tr>`;
    }).join('\n');

    return `<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><title>Portfolio</title>
<style>body{font-family:Arial,sans-serif;margin:2em}table{border-collapse:collapse;width:100%}th,td{border:1px solid #ccc;padding:8px;text-align:left}th{background:#f4f4f4}.star{color:gold;font-size:1.2em}</style>
</head><body><h1>Portfolio</h1><p><em>Last updated: ${ts}</em></p>
<table><thead><tr><th>Ticker</th><th>Name</th><th>Date</th><th>Labels</th><th>Notes</th><th>Rating</th></tr></thead>
<tbody>\n${rows}\n</tbody></table>
<p><small>Generated by Stock Tracker - ${portfolio.length} stocks</small></p></body></html>`;
}

/** Parse portfolio HTML from GitHub */
function parseHtml(content) {
    const doc = new DOMParser().parseFromString(content, 'text/html');
    return [...doc.querySelectorAll('table tbody tr')].map(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length !== 6) return null;
        const ratingMatch = cells[5].textContent.match(/\((\d)\)/);
        return {
            ticker: cells[0].textContent,
            name: cells[1].textContent,
            date: cells[2].textContent,
            labels: cells[3].textContent.split(',').map(l => l.trim()).filter(Boolean),
            notes: cells[4].textContent,
            rating: ratingMatch ? parseInt(ratingMatch[1]) : 0,
            nowPrice: 'Loading...', cumulativeReturn: 'Calculating...', return3m: 'Loading...'
        };
    }).filter(Boolean);
}

/** Save portfolio to GitHub */
async function save() {
    if (!window.githubClient?.isAuthenticated()) {
        document.getElementById('github-auth-modal').style.display = 'flex';
        showStatus('Please authenticate with GitHub first', 'error');
        return;
    }
    showStatus('Saving...', 'info');
    try {
        await window.githubClient.saveFile(generateHtml(), `Update portfolio - ${portfolio.length} stocks`);
        markSaved();
        showStatus(`Saved ${portfolio.length} stocks to GitHub`, 'success');
    } catch (e) {
        showStatus(`Save failed: ${e.message}`, 'error');
    }
}

/** Load portfolio from GitHub */
async function load() {
    try {
        showStatus('Loading from GitHub...', 'info');
        const result = await window.githubClient.loadFile();
        if (!result.exists) {
            showStatus('No portfolio found. Add some stocks!', 'info');
            markSaved();
            return;
        }
        portfolio.length = 0;
        portfolio.push(...parseHtml(result.content));
        markSaved();
        updatePortfolioTable();
        showStatus(`Loaded ${portfolio.length} stocks. Fetching prices...`, 'success');
        await updateAllPrices();
    } catch (e) {
        showStatus(`Load failed: ${e.message}`, 'error');
    }
}

/** Refresh: clear cache and reload */
async function refresh() {
    window.githubClient?.clearCache();
    window.YahooFinance?.clearCache();
    await load();
}

/** Update prices for all stocks, one at a time to avoid WS contention */
async function updateAllPrices() {
    const Y = window.YahooFinance;
    if (!Y) return;

    // Wait for Puter to be ready before any fetches
    await Y.waitForPuter();

    for (let i = 0; i < portfolio.length; i++) {
        const stock = portfolio[i];
        try {
            const [price, histPrice, ret3m] = await Promise.all([
                Y.fetchCurrentPrice(stock.ticker),
                Y.fetchHistoricalPrice(stock.ticker, stock.date),
                Y.fetch3MonthReturn(stock.ticker)
            ]);
            stock.nowPrice = price != null ? price.toFixed(2) : 'N/A';
            stock.cumulativeReturn = (price != null && histPrice != null)
                ? (((price - histPrice) / histPrice) * 100).toFixed(2) : 'N/A';
            stock.return3m = ret3m || 'N/A';
        } catch (e) {
            console.warn(`Update failed for ${stock.ticker}:`, e.message);
            stock.nowPrice = 'N/A'; stock.cumulativeReturn = 'N/A'; stock.return3m = 'N/A';
        }
        debouncedUpdateTable();
        showStatus(`Updated ${i + 1}/${portfolio.length} stocks...`, 'info');
    }
    showStatus(`All ${portfolio.length} stocks updated!`, 'success');
}

/** Add a new stock */
async function addStock(ticker) {
    const Y = window.YahooFinance;
    if (!Y) return;
    const t = ticker.toUpperCase();
    if (portfolio.some(s => s.ticker === t)) { alert(`${t} already in portfolio`); return; }

    const suggestions = await Y.fetchTickerSuggestions(ticker);
    const match = suggestions.find(s => s.symbol.toUpperCase() === t);
    if (!match) { alert('Ticker not found'); return; }

    const stock = {
        ticker: t, name: match.name, date: new Date().toISOString().slice(0, 10),
        labels: [], notes: '', rating: 0,
        nowPrice: '...', cumulativeReturn: '...', return3m: '...', loading: true
    };
    portfolio.push(stock);
    markChanged();
    updatePortfolioTable();

    try {
        const [hist, price, ret3m] = await Promise.all([
            Y.fetchHistoricalPrice(t, stock.date), Y.fetchCurrentPrice(t), Y.fetch3MonthReturn(t)
        ]);
        stock.nowPrice = price != null ? price.toFixed(2) : 'N/A';
        stock.cumulativeReturn = (price != null && hist != null)
            ? (((price - hist) / hist) * 100).toFixed(2) : 'N/A';
        stock.return3m = ret3m || 'N/A';
    } catch { stock.nowPrice = 'N/A'; stock.cumulativeReturn = 'N/A'; stock.return3m = 'N/A'; }
    stock.loading = false;
    updatePortfolioTable();
}

function removeStock(idx) {
    if (!portfolio[idx]) return;
    if (confirm(`Remove ${portfolio[idx].ticker}?`)) {
        portfolio.splice(idx, 1);
        markChanged();
        updatePortfolioTable();
    }
}

function updateRating(idx, r) {
    if (!portfolio[idx]) return;
    portfolio[idx].rating = portfolio[idx].rating === r ? 0 : r;
    markChanged();
    updatePortfolioTable();
}

async function updateDate(idx, date) {
    if (!portfolio[idx]) return;
    portfolio[idx].date = date;
    markChanged();
    const Y = window.YahooFinance;
    try {
        const [hist, price] = await Promise.all([Y.fetchHistoricalPrice(portfolio[idx].ticker, date), Y.fetchCurrentPrice(portfolio[idx].ticker)]);
        portfolio[idx].nowPrice = price ? price.toFixed(2) : 'N/A';
        portfolio[idx].cumulativeReturn = (hist && price) ? (((price - hist) / hist) * 100).toFixed(2) : 'N/A';
        updatePortfolioTable();
    } catch {}
}

function addLabel(idx, label) {
    if (portfolio[idx] && label && !portfolio[idx].labels.includes(label)) {
        portfolio[idx].labels.push(label);
        markChanged(); updatePortfolioTable();
    }
}

function removeLabel(idx, label) {
    if (portfolio[idx]) {
        portfolio[idx].labels = portfolio[idx].labels.filter(l => l !== label);
        markChanged(); updatePortfolioTable();
    }
}

function updateNotes(idx, notes) {
    if (portfolio[idx]) { portfolio[idx].notes = notes; markChanged(); }
}

function getSortedFiltered() {
    let sorted = [...portfolio].sort((a, b) => {
        const diff = (b.rating || 0) - (a.rating || 0);
        if (diff !== 0) return diff;
        if (sortByCumulativeReturn) return (parseFloat(b.cumulativeReturn) || -Infinity) - (parseFloat(a.cumulativeReturn) || -Infinity);
        if (sortBy3MonthReturn) return (parseFloat(b.return3m) || -Infinity) - (parseFloat(a.return3m) || -Infinity);
        return 0;
    });
    if (labelFilterSet.size > 0) sorted = sorted.filter(s => s.labels.some(l => labelFilterSet.has(l)));
    return sorted;
}

window.Portfolio = {
    get data() { return portfolio; },
    get hasUnsavedChanges() { return hasUnsavedChanges; },
    get sortByCumulativeReturn() { return sortByCumulativeReturn; },
    set sortByCumulativeReturn(v) { sortByCumulativeReturn = v; sortBy3MonthReturn = false; },
    get sortBy3MonthReturn() { return sortBy3MonthReturn; },
    set sortBy3MonthReturn(v) { sortBy3MonthReturn = v; sortByCumulativeReturn = false; },
    get labelFilterSet() { return labelFilterSet; },
    get showZeroStarStocks() { return showZeroStarStocks; },
    set showZeroStarStocks(v) { showZeroStarStocks = v; },
    save, load, refresh, add: addStock, remove: removeStock,
    updateRating, updateDate, addLabel, removeLabel, updateNotes,
    getSortedFiltered, markChanged, markSaved, generateHtml
};
